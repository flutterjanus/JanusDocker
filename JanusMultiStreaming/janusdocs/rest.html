<!-- HTML header for doxygen 1.8.18-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RESTful, WebSockets, RabbitMQ, MQTT, Nanomsg and UnixSockets API</title>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/cerulean/bootstrap.min.css" rel="stylesheet">
<link href="css/demo.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<a href="https://github.com/meetecho/janus-gateway"><img style="position: absolute; top: 0; left: 0; border: 0; z-index: 1001;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_darkblue_121621.png" alt="Fork me on GitHub"></a>
<nav class="navbar navbar-default navbar-static-top">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href=".">Janus</a>
		<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>
	</div>
	<div class="navbar-collapse collapse">
		<ul class="nav navbar-nav">
			<li><a href="https://janus.conf.meetecho.com/">Home</a></li>
			<li><a href="https://janus.conf.meetecho.com/demos.html">Demos</a></li>
			<li class="active"><a href="index.html">Documentation</a></li>
			<li><a href="https://janus.conf.meetecho.com/citeus.html">Papers</a></li>
			<li><a href="https://janus.conf.meetecho.com/support.html">Need help?</a></li>
			<li><a class="januscon" target="_blank" href="https://januscon.it">JanusCon!</a></li>
		</ul>
		<div class="navbar-header navbar-right">
			<ul class="nav navbar-nav">
				<li><a target="_blank" href="http://www.meetecho.com" class="navbar-link meetecho-logo"><img src="meetecho-logo.png"/></a></li>
			</ul>
		</div>
	</div>
</div>
</nav>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">RESTful, WebSockets, RabbitMQ, MQTT, Nanomsg and UnixSockets API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Since version <code>0.0.6</code>, there are different ways to interact with a Janus instance: a <a class="el" href="rest.html#plainhttp">Plain HTTP REST Interface</a> (the default), a <a class="el" href="rest.html#WS">WebSockets Interface</a>, a <a class="el" href="rest.html#rabbit">RabbitMQ interface</a>, <a class="el" href="rest.html#apimqtt">MQTT interface</a>, <a class="el" href="rest.html#apinanomsg">Nanomsg interface</a> and a <a class="el" href="rest.html#unix">UnixSockets interface</a> (both optional, need an external library to be available). All of the interfaces use the same messages (in terms of requests, responses and notifications), so almost all the concepts described in the <a class="el" href="rest.html#plainhttp">Plain HTTP REST Interface</a> section apply to the WebSocket/RabbitMQ/MQTT/Nanomsg/UnixSockets interfaces as well. Besides, since version <code>0.1.0</code> the transport mechanism for the Janus API has been made modular, which means other protocols for transporting Janus API messages might become available in the future: considering the Janus protocol is supposed to be mostly agnostic to the protocol it is transported on, the concepts explained in the following sections should apply to those as well.</p>
<p>As it will be explained later in the <a class="el" href="rest.html#WS">WebSockets Interface</a>, <a class="el" href="rest.html#rabbit">RabbitMQ interface</a>, <a class="el" href="rest.html#apimqtt">MQTT interface</a>, <a class="el" href="rest.html#apinanomsg">Nanomsg interface</a> and <a class="el" href="rest.html#unix">UnixSockets interface</a> sections below, the only differences come when addressing specific sessions/handles and in part in how you handle notifications using something different than the REST interface: in fact, since with WebSockets, RabbitMQ, MQTT, Nanomsg and UnixSockets (and, as anticipated, with other protocols that may be added in the future too) there's no REST-based path involved, you'll need a couple of additional identifiers to bridge the gap. Some details are also provided in case you're interested in <a class="el" href="auth.html">Authenticating the Janus API</a>.</p>
<h1><a class="anchor" id="plainhttp"></a>
Plain HTTP REST Interface</h1>
<p>As anticipated in the <a class="el" href="JS.html">JavaScript API</a> documentation, the server deploys a RESTful interface that clients can exploit. The <code>janus.js</code> library makes use of it in a transparent way, but if you're interested in more details about it (e.g., because you want to talk to the server your own way), this page described the interface and the protocol the API exposes and uses.</p>
<p>There are basically three types/levels of endpoints you can meet:</p>
<ol type="1">
<li><a class="el" href="rest.html#root">The server root</a> (<code>/janus</code> by default, but configurable), which you only <b>POST</b> to in order to create a Janus session;</li>
<li><a class="el" href="rest.html#sessions">The session endpoint</a> (e.g., <code>/janus/12345678</code>, using the identifier retrieved with a previous create), which you either send a <b>GET</b> to (long poll for events and messages from plugins) or a <b>POST</b> (to create plugin handles or manipulate the session);</li>
<li><a class="el" href="rest.html#handles">The plugin handle endpoint</a> (e.g., <code>/janus/12345678/98765432</code>, appending the handle identifier to the session one) which you only send <b>POST</b> messages to (messages/negotiations for a plugin, handle manipulation), as all events related to this handle would be received in the session endpoint <b>GET</b> (the <code>janus.js</code> library would redirect the incoming messages to the right handle internally).</li>
</ol>
<p>Messages and requests you can send to and receive from any of the above mentioned endpoints are described in the following chapters. In general, all messages share at least two fields:</p>
<ul>
<li><code>janus:</code> the request/event (e.g., "create", "attach", "message", etc.);</li>
<li><code>transaction:</code> a random string that the client can use to match incoming messages from the server (since, as explained in the <a class="el" href="group__plugins.html">Plugins</a> documentation, all messages are asynchronous).</li>
</ul>
<p>Different messages will of course add different information to this base syntax. Error message, instead, usually have these fields:</p>
<ul>
<li><code>janus:</code> this would be "error";</li>
<li><code>transaction:</code> this would be the transaction identifier of the request that failed;</li>
<li><code>error:</code> a JSON object containing two fields:<ul>
<li><code>code:</code> a numeric error code, as defined in <a class="el" href="apierror_8h.html" title="Janus API errors definition. ">apierror.h</a>;</li>
<li><code>reason:</code> a verbose string describing the cause of the failure.</li>
</ul>
</li>
</ul>
<p>An example of an error is presented here:</p>
<pre class="fragment">{
        "janus" : "error",
        "transaction" : "a1b2c3d4"
        "error" : {
                "code" : 458
                "reason" : "Could not find session 12345678"
        }
}
</pre><h1><a class="anchor" id="info"></a>
Getting info about the Janus instance</h1>
<p>The API exposes an <code>info</code> endpoint you can query to get information about the Janus instance you're talking to. Specifically, it returns information about the version of the Janus server, whether some of the optional features (e.g., Data Channels or IPv6) are supported or not, and which transports and plugins are available.</p>
<p>To get this information, just send an HTTP <b>GET</b> message to the <code>info</code> endpoint (e.g., <a href="http://yourserver:8088/janus/info">http://yourserver:8088/janus/info</a>), which will return something like this:</p>
<pre class="fragment">{
        "janus": "server_info",
        "transaction": "i1bzIL341Kl2",
        "name": "Janus WebRTC Server",
        "version": 73,
        "version_string": "0.7.3",
        "author": "Meetecho s.r.l.",
        "data_channels": "true",        // Data channels are supported
        "ipv6": "false",                        // IPv6 is not configured
        "ice-tcp": "false",                     // ICE-TCP support is disabled,
        [..]
        "transports": {
                "janus.transport.http": {
                        "name": "JANUS REST (HTTP/HTTPS) transport plugin",
                        "author": "Meetecho s.r.l.",
                        "description": "This transport plugin adds REST (HTTP/HTTPS) support to the Janus API via libmicrohttpd.",
                        "version_string": "0.0.2",
                        "version": 2
                },
                [..]    // Other transport plugins
        },
        "plugins": {
                "janus.plugin.sip": {           // The SIP plugin is available
                        "version_string": "0.0.7",
                        "description": "This is a simple SIP plugin for Janus, allowing WebRTC peers to register at a SIP server and call SIP user agents through Janus.",
                        "author": "Meetecho s.r.l.",
                        "name": "JANUS SIP plugin",
                        "version": 7
                },
                "janus.plugin.videoroom": {     // The Video SFU plugin is available
                        "version_string": "0.0.3",
                        "description": "This is a plugin implementing a videoconferencing SFU (Selective Forwarding Unit) for Janus, that is an audio/video router.",
                        "author": "Meetecho s.r.l.",
                        "name": "JANUS VideoRoom plugin",
                        "version": 3
                },
                [..]    // Other plugins
        }
</pre><p>You can use this information to selectively enable or disable features in your application according to what's available in the Janus instance you're trying to contact.</p>
<h1><a class="anchor" id="root"></a>
The server root</h1>
<p>The server root is <code>/janus</code> by default but, as anticipated, it is configurable, either via command line or in the <code>janus.jcfg</code> configuration.</p>
<p>You can only contact the server root when you want to create a new session with the server. To do so, you need to <b>POST</b> the a <code>janus</code> "create" JSON message to the server:</p>
<pre class="fragment">{
        "janus" : "create",
        "transaction" : "&lt;random alphanumeric string&gt;"
}
</pre><p>If the request is successful, you'll receive the unique session identifier in a response formatted like this:</p>
<pre class="fragment">{
        "janus" : "success",
        "transaction" : "&lt;same as the request&gt;",
        "data" : {
                "id" : &lt;unique integer session ID&gt;
        }
}
</pre><p>In case of an error, you'll receive an error message as the one introduced before. This request, if issued with a POST to the server root, can only fail if you miss any of the required fields in the request.</p>
<h1><a class="anchor" id="sessions"></a>
The session endpoint</h1>
<p>Once you've created a session, a new endpoint you can use is created in the server. Specifically, the new endpoint is constructed by concatenating the server root and the session identifier you've been returned (<code>e.g</code>., <code>/janus/12345678</code>).</p>
<p>This endpoint can be used in two different ways:</p>
<ol type="1">
<li>using a parameter-less <b>GET</b> request to the endpoint, you'll issue a long-poll request to be notified about events and incoming messages from this session;</li>
<li>using a <b>POST</b> request to send JSON messages, you'll interact with the session itself.</li>
</ol>
<hr/>
<dl class="section user"><dt>Long-poll requests</dt><dd>The long-poll will only trigger events related to messages you're being sent from plugins, and as such will be clearer to understand once you read the <a class="el" href="rest.html#handles">The plugin handle endpoint</a> section. That said, the events are formatted this way:</dd></dl>
<ul>
<li><code>janus:</code> this would be "event";</li>
<li><code>sender:</code> this would be the unique numeric plugin handle identifier;</li>
<li><code>transaction:</code> this is optional: it is either related to a request you sent to a plugin before, or it may be missing in case this is an event the plugin sent on its own account;</li>
<li><code>plugindata:</code> a JSON object containing the info coming from the plugin itself:<ul>
<li><code>plugin:</code> the plugin's unique package name (e.g., <code>janus.plugin.echotest</code>);</li>
<li><code>data:</code> an opaque JSON object that is plugin specific.</li>
</ul>
</li>
<li><code>jsep:</code> an optional JSON object containing the JSEP SDP (offer or answer) the plugin may send to negotiate a WebRTC PeerConnection with the client (check the <a class="el" href="rest.html#handles">The plugin handle endpoint</a> section for more details).</li>
</ul>
<p>An example of such an event (in this case, sent by the <a class="el" href="janus__echotest_8c.html" title="Janus EchoTest plugin. ">janus_echotest.c</a> plugin in response to a request) is presented here:</p>
<pre class="fragment">{
        "janus" : "event",
        "sender" : 1815153248,
        "transaction" : "sBJNyUhH6Vc6",
        "plugindata" : {
                "plugin": "janus.plugin.echotest",
                "data" : {
                        "echotest" : "event",
                        "result" : "ok"
                }
        },
}
</pre><p>The long-poll request has a 30 seconds timeout. If it has no event to report, a simple <em>keep-alive</em> message will be triggered:</p>
<pre class="fragment">{
        "janus" : "keepalive",
}
</pre><p>As with all long-poll based approaches, it's up to your application to send a new polling request as soon as an event or a keep-alive has been received.</p>
<p>Notice that, by default, the long poll returns a single event: that is, as soon as a message becomes available in the session queue, that event is returned and the long poll closes. If you want to receive more events within the context of the same long poll, you can pass the <code>maxev</code> query string parameter to the GET, e.g.:</p>
<pre class="fragment">GET http://host:port/janus/&lt;sessionid&gt;?maxev=5
</pre><pre class="fragment">[
        {
                // Event #1
                "janus" : "event",
                [..]
        },
        {
                // Event #2
                "janus" : "event",
                [..]
        },
        [..]
]
</pre><p>This request will instruct the server to return at maximum 5 events within the context of the same long poll, formatted as a JSON array of events. Please beware that this does <b>NOT</b> mean that you'll always get 5 events this way: it only means that, if a message becomes available in the queue and more events are present as well, Janus will return more than one without needing you to send multiple long polls immediately thereafter to get them. For this reason, don't be surprised if even with a <code>maxev</code> parameter set, you'll still get a single event being notified as the sole object in the returned array.</p>
<hr/>
<dl class="section user"><dt>Interacting with the session</dt><dd>To interact with the session, e.g., to create a new handle to attach to a plugin or destroy the current session, you need to send a <b>POST</b> JSON message to the session endpoint.</dd></dl>
<p>To attach to a plugin in order to exploit its features, you need to <b>POST</b> a <code>janus</code> "attach" JSON message to the server; you'll need of course to provide information on the plugin you want to attach to, which can be done using the <code>plugin</code> field:</p>
<pre class="fragment">{
        "janus" : "attach",
        "plugin" : "&lt;the plugin's unique package name&gt;",
        "transaction" : "&lt;random string&gt;"
}
</pre><p>Notice that you can also provide an optional <code>opaque_id</code> string identifier (for more details on why this might be useful, read more <a href="https://github.com/meetecho/janus-gateway/pull/748">here</a>). If the request is successful, you'll receive the unique plugin handle identifier in a response formatted the same way as the session create one, that is like this:</p>
<pre class="fragment">{
        "janus" : "success",
        "transaction" : "&lt;same as the request&gt;",
        "data" : {
                "id" : &lt;unique integer plugin handle ID&gt;
        }
}
</pre><p>In case of an error, you'll receive an error message as the one introduced before. This request, if issued with a POST to a valid session endpoint, can only fail if you miss any of the required fields in the request or if the plugin you requested is not available in the server.</p>
<p>To destroy the current session, instead, just send a "destroy" <code>janus</code> request:</p>
<pre class="fragment">{
        "janus" : "destroy",
        "transaction" : "&lt;random string&gt;"
}
</pre><p>This will also destroy the endpoint created for this session. If your session is currently managing one or more plugin handles, make sure you destroy them first (as explained in the next section). The server tries to do this automatically when receiving a session destroy request, but a cleaner approach on the client side would help nonetheless avoid potential issues.</p>
<h1><a class="anchor" id="handles"></a>
The plugin handle endpoint</h1>
<p>Once you've created a plugin handle, a new endpoint you can use is created in the server. Specifically, the new endpoint is constructed by concatenating the server root, the session identifier and the new plugin handle identifier you've been returned (<code>e.g</code>., <code>/janus/12345678/98765432</code>).</p>
<p>You can use this plugin handle for everything that is related to the communication with a plugin, that is, send the plugin a message, negotiate a WebRTC connection to attach to the plugin, and so on.</p>
<p>To send a plugin a message/request, you need to <b>POST</b> the handle endpoint a <code>janus</code> "message" JSON payload. The <code>body</code> field will have to contain a plugin-specific JSON payload. In case the message also needs to convey WebRTC-related negotiation information, a <code>jsep</code> field containing the JSON-ified version of the JSEP object can be attached as well.</p>
<dl class="section note"><dt>Note</dt><dd>If you attach a <code>jsep</code> object, whether it's an offer or an answer, you're stating your will to negotiate a PeerConnection. This means that an empty or invalid <code>jsep</code> object will trigger a validation and will cause the whole request to fail, so make sure you exclude the field completely from your request if all you're interested into is sending a message to a plugin.</dd></dl>
<p>Here's an example of a message you may send the <a class="el" href="janus__echotest_8c.html" title="Janus EchoTest plugin. ">janus_echotest.c</a> plugin to mute your audio:</p>
<pre class="fragment">{
        "janus" : "message",
        "transaction" : "sBJNyUhH6Vc6",
        "body" : {
                "audio" : false
        }
}
</pre><p>The same message containing negotiation information as well, instead, (an OFFER, in this example), is presented here:</p>
<pre class="fragment">{
        "janus" : "message",
        "transaction" : "sBJNyUhH6Vc6",
        "body" : {
                "audio" : false
        },
        "jsep" : {
                "type" : "offer",
                "sdp" : "v=0\r\no=[..more sdp stuff..]"
        }
}
</pre><p>Please notice that, if for any reason you don't want to use the trickling of ICE candidates from your application (which means you'll include them all in the SDP OFFER or ANSWER, which is usually not recommended), you'll have to add an additional <code>"trickle" : false</code> attribute to the "jsep" object, to explicitly tell Janus you won't send any <code>trickle</code> candidate (by default Janus will always assume support for trickle).</p>
<p>If you're going to <code>trickle</code> candidates, instead, there is an ad-hoc message you can use to do so which is called, unsurprisingly, <code>trickle</code> and which you can use to send one or more trickle candidates to Janus. Since such a message is related to a specific PeerConnection, it will need to be addressed to the right Handle just as the <code>message</code> introduced previously. A <code>trickle</code> message can contain three different kind of information:</p>
<ul>
<li>a single trickle candidate;</li>
<li>an array of trickle candidates;</li>
<li>a null candidate or a <code>completed</code> JSON object to notify the end of the candidates.</li>
</ul>
<p>This is an example of a single candidate being trickled:</p>
<pre class="fragment">{
        "janus" : "trickle",
        "transaction" : "hehe83hd8dw12e",
        "candidate" : {
                "sdpMid" : "video",
                "sdpMLineIndex" : 1,
                "candidate" : "..."
        }
}
</pre><p>This, instead, is an example of how to group more trickle candidates in a single request (particularly useful if you're wrapping Janus in your server and want to reduce the number of transactions):</p>
<pre class="fragment">{
        "janus" : "trickle",
        "transaction" : "hehe83hd8dw12e",
        "candidates" : [
                {
                        "sdpMid" : "video",
                        "sdpMLineIndex" : 1,
                        "candidate" : "..."
                },
                {
                        "sdpMid" : "video",
                        "sdpMLineIndex" : 1,
                        "candidate" : "..."
                },
                [..]
        ]
}
</pre><p>Finally, this is how you can tell Janus that you sent all the trickle candidates that were gathered:</p>
<pre class="fragment">{
        "janus" : "trickle",
        "transaction" : "hehe83hd8dw12e",
        "candidate" : {
                "completed" : true
        }
}
</pre><p>Plugins may handle this requests synchronously or asynchronously. In the former, plugins would return a response to the request itself immediately; in the latter, instead, the plugin would only notify a successful reception of the request, which it would process later. Considering the asynchronous nature of the Janus API, a successful management of such messages within Janus would in such case result in a <code>janus</code> "ack" messages being sent back to the client. A logical response to those messages, if needed, would be provided as an event in the long-poll interface described previously, and clients would be able to match it to the original request by means of the transaction identifiers. It is worth noting, though, that should a WebRTC negotiation be involved you don't have to expect an ANSWER to your OFFER to be sent back in the same transaction. A plugin may decide, in its application logic, to not provide you with an ANSWER right away, but only after some internal state changes occur. It's up to your application to handle the negotiation state accordingly.</p>
<p>An example of an "ack" being sent back to the client, using the previous sample request as a reference, is presented here:</p>
<pre class="fragment">{
        "janus" : "ack",
        "transaction" : "sBJNyUhH6Vc6"
}
</pre><p>If you receive this ack instead of a "success" response, you can be sure the plugin has received the message, and is going to process it soon.</p>
<p>In case of an error, instead, you'll receive an error message as the one introduced before. This request, if issued with a POST to a valid plugin handle endpoint, can only fail if you miss any of the required fields in the request, if the plugin you tried to contact is not available in the server anymore, if an error occurred in the plugin when trying to receive the message or if the <code>jsep</code> SDP you may have provided is invalid.</p>
<p>To destroy the plugin handle, instead, just send a "detach" <code>janus</code> request:</p>
<pre class="fragment">{
        "janus" : "detach",
        "transaction" : "&lt;random string&gt;"
}
</pre><p>This will also destroy the endpoint created for this plugin handle. If your plugin handle is also managing an ongoing WebRTC connection with the plugin, make sure it is torn down as part of this process. The plugin implementation and the Janus core should do this automatically, but implementing the right behaviour in clients would help avoid potential issues nonetheless.</p>
<p>If you're interested in keeping the handle alive but want to hang up the associated PeerConnection, if available, just send a "hangup" <code>janus</code> request:</p>
<pre class="fragment">{
        "janus" : "hangup",
        "transaction" : "&lt;random string&gt;"
}
</pre><p>This is usually not required, as you can typically just hangup your WebRTC PeerConnection normally and Janus will figure out it's gone by itself. Anyway, there are cases where this might be useful (e.g., the connection was stuck in some weird ICE/DTLS state) as it can be used to reset the connection state for the handle.</p>
<h1><a class="anchor" id="events"></a>
WebRTC-related events</h1>
<p>As anticipated in the previous sections, Janus can send events and notifications at any time through the long poll channel (or, as it will be explained later, through the related push mechanisms made available by other transport protocols ). While this channel is mostly used to convey asynchronous notifications originated by plugins as part of the messaging they may have with the application using it, the same channel is actually used by Janus to trigger events related to different aspects pertaining a specific handle.</p>
<p>In particular, for each handle involving a PeerConnection Janus provides notifications about its current state. To do so, the following events may be received as well:</p>
<ul>
<li><code>webrtcup:</code> ICE and DTLS succeeded, and so Janus correctly established a PeerConnection with the user/application;</li>
<li><code>media:</code> whether Janus is receiving (<code>receiving:</code> <code>true/false</code>) audio/video (<code>type:</code> <code>"audio/video"</code>) on this PeerConnection;</li>
<li><code>slowlink:</code> whether Janus is reporting trouble sending/receiving (<code>uplink:</code> <code>true/false</code>) media on this PeerConnection;</li>
<li><code>hangup:</code> the PeerConnection was closed, either by Janus or by the user/application, and as such cannot be used anymore.</li>
</ul>
<p>As such, to monitor the status of a PeerConnection as seen from Janus you can make use of these events to track what's going on. A correct flow for an active PeerConnection would be one that, after a WebRTC negotiation and setup, results in a <code>webrtcup</code> event followed by two <code>media</code> events (in case both audio and video have been negotiated) specifying that the first audio/video packets have been received. A <code>hangup</code> event would inform the user/application that no media is being exchanged with Janus anymore.</p>
<p>Here are a few examples of how these events may look like.</p>
<p>A PeerConnection becoming ready:</p>
<pre class="fragment">{
        "janus" : "webrtcup",
        session_id: &lt;the session identifier&gt;,
        sender: &lt;the handle identifier&gt;
}
</pre><p>First audio bytes being received by Janus:</p>
<pre class="fragment">{
        "janus" : "media",
        session_id: &lt;the session identifier&gt;,
        sender: &lt;the handle identifier&gt;,
        "type" : "audio",
        "receiving" : true
}
</pre><p>Audio not getting to Janus anymore for some reason:</p>
<pre class="fragment">{
        "janus" : "media",
        "session_id" : &lt;the session identifier&gt;,
        "sender" : &lt;the handle identifier&gt;
        "type" : "audio",
        "receiving" : false
}
</pre><p>Audio getting to Janus again (same message as first audio):</p>
<pre class="fragment">{
        "janus" : "media",
        "session_id" : &lt;the session identifier&gt;,
        "sender" : &lt;the handle identifier&gt;
        "type" : "audio",
        "receiving" : true
}
</pre><p>Janus reporting problems sending media to a user (user sent many NACKs in the last second; uplink=true is from Janus' perspective):</p>
<pre class="fragment">{
        "janus" : "slowlink",
        "session_id" : &lt;the session identifier&gt;,
        "sender" : &lt;the handle identifier&gt;
        "uplink" : true,
        "nacks" : &lt;number of NACKs in the last second&gt;
}
</pre><p>PeerConnection closed for a DTLS alert (normal shutdown):</p>
<pre class="fragment">{
        "janus" : "hangup",
        "session_id" : &lt;the session identifier&gt;,
        "sender" : &lt;the handle identifier&gt;,
        "reason" : "DTLS alert"
}
</pre><p>It is important to point out that the <code>media</code> event notifications only apply if your PeerConnection is going to actually send media to Janus. A <code>recvonly</code> PeerConnection, for instance (e.g., as the Streaming plugin would create) would never trigger any <code>media</code> event, as Janus would never be receiving media, but only send it.</p>
<h1><a class="anchor" id="WS"></a>
WebSockets Interface</h1>
<p>WebSockets provide a more efficient means for implementing a bidirectional communication. This is especially useful if you're wrapping the Janus API on your servers, as it allows you to avoid all the noise and overhead introduced by several concurrent HTTP transactions and long polls by relying on what may be seen as a single "control channel".</p>
<p>To interact with Janus using WebSockets you MUST specify a specific subprotocol, named <code>janus-protocol</code>, e.g.,</p>
<pre class="fragment">var websocket = new WebSocket('ws://1.2.3.4:8188', 'janus-protocol');
</pre><p>The <code>janus.js</code> library does this automatically.</p>
<p>As anticipated at the beginning of this section, the actual messages being exchanged are exactly the same. This means that all the concepts introduced before still apply: you still create a session, attach to a plugin and interact with it exactly the same way. What is different is, of course, the REST path approach that becomes unavailable when using a WebSocket as a control channel. To address the idenfitiers that become missing using WebSockets, you'll need to add additional fields to the requests when necessary.</p>
<p>So, when you want to create a session using the REST API, you send a POST to the server base path:</p>
<pre class="fragment">{
        "janus" : "create",
        "transaction" : "&lt;random alphanumeric string&gt;"
}
</pre><p>The same applies if you're interested in getting generic info from the Janus instance. Since there's no <b>GET</b> you can use, a specific <code>janus</code> request type called <code>info</code> is available:</p>
<pre class="fragment">{
        "janus" : "info",
        "transaction" : "&lt;random alphanumeric string&gt;"
}
</pre><p>Since you'd contact the base path for both requests, you don't need to add any identifier for this scenario. But if instead you want to attach to a plugin within the context of a specific session, using the REST API you'd send a post to the <code>/janus/&lt;session-id&gt;</code> endpoint:</p>
<pre class="fragment">{
        "janus" : "attach",
        "plugin" : "&lt;the plugin's unique package name&gt;",
        "transaction" : "&lt;random string&gt;"
}
</pre><p>To make this work with WebSockets as well, you need to add a further field called <code>session_id</code> in the request:</p>
<pre class="fragment">{
        "janus" : "attach",
        "session_id" : &lt;the session identifier&gt;,                // NEW!
        "plugin" : "&lt;the plugin's unique package name&gt;",
        "transaction" : "&lt;random string&gt;"
}
</pre><p>which will allow the WebSocket server to understand which session this request pertains to. At the same time, when you need to address a specific handle (e.g., to send a message to a plugin, or negotiate a WebRTC PeerConnection) you'll need to add a <code>handle_id</code> field to the request as well, or the request will be rejected:</p>
<pre class="fragment">{
        "janus" : "message",
        "session_id" : &lt;the session identifier&gt;,                // NEW!
        "handle_id" : &lt;the handle identifier&gt;,          // NEW!
        "transaction" : "sBJNyUhH6Vc6",
        "body" : {
                "audio" : false
        }
}
</pre><p>Considering the bidirectional nature of WebSockets and the fact that the channel will be shared for different requests, you'll need to pay extra attention to the <code>transaction</code> identifier, which will allow you to map incoming responses and events to the request you sent that originated them.</p>
<p>An <b>important</b> aspect to point out is related to keep-alive messages for WebSockets Janus channels. A Janus session is kept alive as long as there's no inactivity for 60 seconds: if no messages have been received in that time frame, the session is torn down by the server. A normal activity on a session is usually enough to prevent that; for a more prolonged inactivity with respect to messaging, on plain HTTP the session is usually kept alive through the regular long poll requests, which act as activity as long as the session is concerned. This aid is obviously not possible when using WebSockets, where a single channel is used both for sending requests and receiving events and responses. For this reason, an ad-hoc message for keeping alive a Janus session should to be triggered on a regular basis:</p>
<pre class="fragment">{
        "janus" : "keepalive",
        "session_id" : &lt;the session identifier&gt;,
        "transaction" : "sBJNyUhH6Vc6"
}
</pre><p>This will make sure that the server detects activity on the session even when no actual messages are being exchanged with handles.</p>
<p>As a last point, another slight difference with WebSockets comes from how push notifications are implemented. In the <a class="el" href="rest.html#plainhttp">Plain HTTP REST Interface</a> this is done via long polls: that is, you explicitly subscribe to notifications, and have to do that again as soon as an event has been received. With WebSockets, this is not needed: as soon as you create a session on a WebSocket, that channel becomes automatically subscribed for events related to that sessions, and you'll receive them on the same WebSocket. For the same reason, as soon as the WebSocket is closed, all the sessions created within its context are considered closed as well, and so their resources (including all the handles and PeerConnections) will be released as well.</p>
<dl class="section note"><dt>Note</dt><dd>The same <code>janus.js</code> JavaScript library can be used both with the REST and the WebSockets API: all you need to do is provide the right Janus server address during the initialization and the library will use one or the other according to the protocol prefix.</dd></dl>
<h1><a class="anchor" id="rabbit"></a>
RabbitMQ interface</h1>
<p>The semantics of how the requests have to be built, when compared to the usage of plain HTTP, is exactly the same as for WebSockets, so refer to the <a class="el" href="rest.html#WS">WebSockets Interface</a> documentation for details about that.</p>
<p>Of course, there are other aspects that differ when making use of RabbitMQ messaging to talk to Janus, rather than using HTTP messages or WebSockets. Specifically, RabbitMQ just basically forwards messages on queues, and as such implementing a pseudo-bidirectional channel as the Janus API requires some precaution.</p>
<p>In particular, when configuring Janus to use RabbitMQ you'll have to specify <b>two</b> <b>queues:</b> </p>
<ul>
<li>a queue for <b>incoming</b> messages (application -&gt; Janus);</li>
<li>a queue for <b>outgoing</b> messages (Janus -&gt; application).</li>
</ul>
<p>The proper usage of these queues will allow you to implement the kind of bidirectional channel Janus needs.</p>
<p>Another aspect to point out is that Janus requires all requests to have a random <code>correlation_id</code> identifier. In fact, as pointed out in the previous sections, the Janus API is conceived as a request/response protocol that can involve asynchronous notifications as well. In order to make sure that an application can match a received response to one of the requests made earlier, Janus copies the <code>correlation_id</code> identifier from the original request in the response to it: this is compliant with the <a href="https://www.rabbitmq.com/tutorials/tutorial-six-python.html">RPC pattern</a> as specified in the RabbitMQ documentation. Notifications originated by Janus, instead, will not include a <code>correlation_id</code> identifier, and as such applications shouldn't expect any: applications will still be able to match a notification to a request, if the involved plugin was implemented to do so, by looking at the Janus-level <code>transaction</code> identifier.</p>
<h1><a class="anchor" id="apimqtt"></a>
MQTT interface</h1>
<p>The semantics of how the requests have to be built, when compared to the usage of plain HTTP, is exactly the same as for WebSockets, so refer to the <a class="el" href="rest.html#WS">WebSockets Interface</a> documentation for details about that.</p>
<p>Of course, there are other aspects that differ when making use of MQTT messaging to talk to Janus, rather than using HTTP messages or WebSockets. Similar to RabbitMQ, MQTT just basically forwards messages on queues, and as such implementing a pseudo-bidirectional channel as the Janus API requires some precaution.</p>
<p>In particular, when configuring Janus to use MQTT you'll have to specify <b>two</b> <b>queues:</b> </p>
<ul>
<li>a queue for <b>incoming</b> messages (application -&gt; Janus);</li>
<li>a queue for <b>outgoing</b> messages (Janus -&gt; application).</li>
</ul>
<p>The proper usage of these queues will allow you to implement the kind of bidirectional channel Janus needs.</p>
<h1><a class="anchor" id="apinanomsg"></a>
Nanomsg interface</h1>
<p>The semantics of how the requests have to be built, when compared to the usage of plain HTTP, is exactly the same as for WebSockets, RabbitMQ and MQTT, so refer to the <a class="el" href="rest.html#WS">WebSockets Interface</a> documentation for details about that.</p>
<p>Apart from that, the only configuration needed is related to the Nanomsg address to use, and whether it should be used to bind locally or to connect to a remote endpoint. Notice that only the <code>NN_PAIR</code> pattern is supported by the plugin, so no Pub/Sub or other variations.</p>
<h1><a class="anchor" id="unix"></a>
UnixSockets interface</h1>
<p>The semantics of how the requests have to be built, when compared to the usage of plain HTTP, is exactly the same as for WebSockets, RabbitMQ MQTT and Nanomsg, so refer to the <a class="el" href="rest.html#WS">WebSockets Interface</a> documentation for details about that.</p>
<p>Apart from that, the only configuration needed is related to the path the client and server will be sharing, and the socket type. Notice that only the <code>SOCK_SEQPACKET</code> and <code>SOCK_DGRAM</code> types are supported in the plugin. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.18-->
<!-- start footer part -->
<div class="footer container">
<hr class="footer"/>
Last updated on Fri Apr 9 2021 &mdash; Janus WebRTC Server &copy; <a target="_blank" href="http://www.meetecho.com/">Meetecho</a> 2014-2021
</div>
</body>
</html>
