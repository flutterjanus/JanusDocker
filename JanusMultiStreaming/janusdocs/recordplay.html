<!-- HTML header for doxygen 1.8.18-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Record&amp;Play plugin documentation</title>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/cerulean/bootstrap.min.css" rel="stylesheet">
<link href="css/demo.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<a href="https://github.com/meetecho/janus-gateway"><img style="position: absolute; top: 0; left: 0; border: 0; z-index: 1001;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_darkblue_121621.png" alt="Fork me on GitHub"></a>
<nav class="navbar navbar-default navbar-static-top">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href=".">Janus</a>
		<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>
	</div>
	<div class="navbar-collapse collapse">
		<ul class="nav navbar-nav">
			<li><a href="https://janus.conf.meetecho.com/">Home</a></li>
			<li><a href="https://janus.conf.meetecho.com/demos.html">Demos</a></li>
			<li class="active"><a href="index.html">Documentation</a></li>
			<li><a href="https://janus.conf.meetecho.com/citeus.html">Papers</a></li>
			<li><a href="https://janus.conf.meetecho.com/support.html">Need help?</a></li>
			<li><a class="januscon" target="_blank" href="https://januscon.it">JanusCon!</a></li>
		</ul>
		<div class="navbar-header navbar-right">
			<ul class="nav navbar-nav">
				<li><a target="_blank" href="http://www.meetecho.com" class="navbar-link meetecho-logo"><img src="meetecho-logo.png"/></a></li>
			</ul>
		</div>
	</div>
</div>
</nav>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Record&amp;Play plugin documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This is a simple application that implements two different features: it allows you to record a message you send with WebRTC in the format defined in recorded.c (MJR recording) and subsequently replay this recording (or other previously recorded) through WebRTC as well. For more information on how Janus implements recordings natively and the MJR format, refer to the <a class="el" href="recordings.html">Recordings</a> documentation.</p>
<p>This application aims at showing how easy recording frames sent by a peer is, and how this recording can be re-used directly, without necessarily involving a post-processing process (e.g., through the tool we provide in <a class="el" href="janus-pp-rec_8c.html" title="Simple utility to post-process .mjr Recordings saved by Janus. ">janus-pp-rec.c</a>). Notice that only audio and video can be recorded and replayed in this plugin: if you're interested in recording data channel messages (which Janus and the .mjr format do support), you should use a different plugin instead.</p>
<p>The configuration process is quite easy: just choose where the recordings should be saved. The same folder will also be used to list the available recordings that can be replayed.</p>
<dl class="section note"><dt>Note</dt><dd>The application creates a special file in INI format with <code>.nfo</code> extension for each recording that is saved. This is necessary to map a specific audio .mjr file to a different video .mjr one, as they always get saved in different files. If you want to replay recordings you took in a different application (e.g., the streaming or videoroom plugins) just copy the related files in the folder you configured this plugin to use and create a .nfo file in the same folder to create a mapping, e.g.: <pre class="fragment">         [12345678]
         name = My videoroom recording
         date = 2014-10-14 17:11:26
         audio = videoroom-audio.mjr
         video = videoroom-video.mjr
</pre></dd></dl>
<p>Data channel recordings are supported via a <code>data</code> attribute as well.</p>
<h1><a class="anchor" id="recplayapi"></a>
Record&amp;Play API</h1>
<p>The Record&amp;Play API supports several requests, some of which are synchronous and some asynchronous. There are some situations, though, (invalid JSON, invalid request) which will always result in a synchronous error response even for asynchronous requests.</p>
<p><code>list</code> and <code>update</code> are synchronous requests, which means you'll get a response directly within the context of the transaction. <code>list</code> lists all the available recordings, while <code>update</code> forces the plugin to scan the folder of recordings again in case some were added manually and not indexed in the meanwhile.</p>
<p>The <code>record</code> , <code>play</code> , <code>start</code> and <code>stop</code> requests instead are all asynchronous, which means you'll get a notification about their success or failure in an event. <code>record</code> asks the plugin to start recording a session; <code>play</code> asks the plugin to prepare the playout of one of the previously recorded sessions; <code>start</code> starts the actual playout, and <code>stop</code> stops whatever the session was for, i.e., recording or replaying.</p>
<p>The <code>list</code> request has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "list"
}
</pre><p>A successful request will result in an array of recordings:</p>
<pre class="fragment">{
        "recordplay" : "list",
        "list": [       // Array of recording objects
                {                       // Recording #1
                        "id": &lt;numeric ID&gt;,
                        "name": "&lt;Name of the recording&gt;",
                        "date": "&lt;Date of the recording&gt;",
                        "audio": "&lt;Audio rec file, if any; optional&gt;",
                        "video": "&lt;Video rec file, if any; optional&gt;",
                        "data": "&lt;Data rec file, if any; optional&gt;",
                        "audio_codec": "&lt;Audio codec, if any; optional&gt;",
                        "video_codec": "&lt;Video codec, if any; optional&gt;"
                },
                &lt;other recordings&gt;
        ]
}
</pre><p>An error instead (and the same applies to all other requests, so this won't be repeated) would provide both an error code and a more verbose description of the cause of the issue:</p>
<pre class="fragment">{
        "recordplay" : "event",
        "error_code" : &lt;numeric ID, check Macros below&gt;,
        "error" : "&lt;error description as a string&gt;"
}
</pre><p>The <code>update</code> request instead has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "update"
}
</pre><p>which will always result in an immediate ack ( <code>ok</code> ):</p>
<pre class="fragment">{
        "recordplay" : "ok",
}
</pre><p>Coming to the asynchronous requests, <code>record</code> has to be attached to a JSEP offer (failure to do so will result in an error) and has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "record",
        "id" : &lt;unique numeric ID for the recording; optional, will be chosen by the server if missing&gt;
        "name" : "&lt;Pretty name for the recording&gt;",
        "filename" : "&lt;Base path/name for the file (media type and extension added by the plugin); optional&gt;",
        "audiocodec" : "&lt;name of the audio codec we prefer for the recording; optional&gt;",
        "videocodec" : "&lt;name of the video codec we prefer for the recording; optional&gt;",
        "videoprofile" : "&lt;in case the video codec supports, profile to use (e.g., "2" for VP9, or "42e01f" for H.264); optional&gt;",
        "textdata" : "&lt;in case data channels have to be recorded, whether the data will be text (default) or binary; optional&gt;"
}
</pre><p>A successful management of this request will result in a <code>recording</code> event which will include the unique ID of the recording and a JSEP answer to complete the setup of the associated PeerConnection to record:</p>
<pre class="fragment">{
        "recordplay" : "event",
        "result": {
                "status" : "recording",
                "id" : &lt;unique numeric ID&gt;
        }
}
</pre><p>A <code>stop</code> request can interrupt the recording process and tear the associated PeerConnection down:</p>
<pre class="fragment">{
        "request" : "stop",
}
</pre><p>This will result in a <code>stopped</code> status:</p>
<pre class="fragment">{
        "recordplay" : "event",
        "result": {
                "status" : "stopped",
                "id" : &lt;unique numeric ID of the interrupted recording&gt;
        }
}
</pre><p>For what concerns the playout, instead, the process is slightly different: you first choose a recording to replay, using <code>play</code> , and then start its playout using a <code>start</code> request. Just as before, a <code>stop</code> request will interrupt the playout and tear the PeerConnection down. It's very important to point out that no JSEP offer must be sent for replaying a recording: in this case, it will always be the plugin to generate a JSON offer (in response to a <code>play</code> request), which means you'll then have to provide a JSEP answer within the context of the following <code>start</code> request which will close the circle.</p>
<p>A <code>play</code> request has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "play",
        "id" : &lt;unique numeric ID of the recording to replay&gt;
}
</pre><p>This will result in a <code>preparing</code> status notification which will be attached to the JSEP offer originated by the plugin in order to match the media available in the recording:</p>
<pre class="fragment">{
        "recordplay" : "event",
        "result": {
                "status" : "preparing",
                "id" : &lt;unique numeric ID of the recording&gt;
        }
}
</pre><p>A <code>start</code> request, which as anticipated must be attached to the JSEP answer to the previous offer sent by the plugin, has to be formatted as follows:</p>
<pre class="fragment">{
        "request" : "start",
}
</pre><p>This will result in a <code>playing</code> status notification:</p>
<pre class="fragment">{
        "recordplay" : "event",
        "result": {
                "status" : "playing"
        }
}
</pre><p>Just as before, a <code>stop</code> request can interrupt the playout process at any time, and tear the associated PeerConnection down:</p>
<pre class="fragment">{
        "request" : "stop",
}
</pre><p>This will result in a <code>stopped</code> status:</p>
<pre class="fragment">{
        "recordplay" : "event",
        "result": {
                "status" : "stopped"
        }
}
</pre><p>If the plugin detects a loss of the associated PeerConnection, whether as a result of a <code>stop</code> request or because the 10 seconds passed, a <code>done</code> result notification is triggered to inform the application the recording/playout session is over:</p>
<pre class="fragment">{
        "recordplay" : "event",
        "result": "done"
}
</pre> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.18-->
<!-- start footer part -->
<div class="footer container">
<hr class="footer"/>
Last updated on Fri Apr 9 2021 &mdash; Janus WebRTC Server &copy; <a target="_blank" href="http://www.meetecho.com/">Meetecho</a> 2014-2021
</div>
</body>
</html>
