<!-- HTML header for doxygen 1.8.18-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>JavaScript API</title>
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/cerulean/bootstrap.min.css" rel="stylesheet">
<link href="css/demo.css" rel="stylesheet">
<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js"></script>
<script type="text/javascript" src="doxy-boot.js"></script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<a href="https://github.com/meetecho/janus-gateway"><img style="position: absolute; top: 0; left: 0; border: 0; z-index: 1001;" src="https://s3.amazonaws.com/github/ribbons/forkme_left_darkblue_121621.png" alt="Fork me on GitHub"></a>
<nav class="navbar navbar-default navbar-static-top">
<div class="container">
	<div class="navbar-header">
		<a class="navbar-brand" href=".">Janus</a>
		<button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
			<span class="icon-bar"></span>
		</button>
	</div>
	<div class="navbar-collapse collapse">
		<ul class="nav navbar-nav">
			<li><a href="https://janus.conf.meetecho.com/">Home</a></li>
			<li><a href="https://janus.conf.meetecho.com/demos.html">Demos</a></li>
			<li class="active"><a href="index.html">Documentation</a></li>
			<li><a href="https://janus.conf.meetecho.com/citeus.html">Papers</a></li>
			<li><a href="https://janus.conf.meetecho.com/support.html">Need help?</a></li>
			<li><a class="januscon" target="_blank" href="https://januscon.it">JanusCon!</a></li>
		</ul>
		<div class="navbar-header navbar-right">
			<ul class="nav navbar-nav">
				<li><a target="_blank" href="http://www.meetecho.com" class="navbar-link meetecho-logo"><img src="meetecho-logo.png"/></a></li>
			</ul>
		</div>
	</div>
</div>
</nav>
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">JavaScript API </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Janus exposes, assuming the HTTP transport has been compiled, a pseudo-RESTful interface, and optionally also WebSocket/RabbitMQ/MQTT/Nanomsg/UnixSockets interfaces as well, all of which based on JSON messages. These interfaces are described in more detail in the <a class="el" href="rest.html#plainhttp">Plain HTTP REST Interface</a> <a class="el" href="rest.html#WS">WebSockets Interface</a> <a class="el" href="rest.html#rabbit">RabbitMQ interface</a> <a class="el" href="rest.html#apimqtt">MQTT interface</a> <a class="el" href="rest.html#apinanomsg">Nanomsg interface</a> and <a class="el" href="rest.html#unix">UnixSockets interface</a> documentation respectively, and all allow clients to take advantage of the features provided by Janus and the functionality made available by its plugins. Considering most clients will be web browsers, a common choice will be to rely on either the REST or the WebSockets interface for the purpose. To make things easier for web developers, a JavaScript library (<code>janus.js</code>) is available that can make use of both interfaces using exactly the same API. This library eases the task of creating sessions with the Janus core, attaching WebRTC users to plugins, send and receive requests and events to the plugins themselves and so on. For real examples of how this library can be used, check the demos in the <b>html</b> folder of this package. Notice that the <code>janus.js</code> library makes use of the features made available by the <a href="https://github.com/webrtc/adapter">webrtc-adapter</a> shim, which means that your web application should always include it as a dependency. For instance, all the demos link to it externally via <a href="https://cdnjs.com/">cdnjs.com</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The current <code>janus.js</code> library allows you to provide custom implementations of certain dependencies, in order to make it easier to integrate with other JavaScript libraries and frameworks. Using this feature you can ensure <code>janus.js</code> does not (implicitly) depend on certain global variables. Two implementations are included in <code>janus.js</code> itself:</dd></dl>
<ol type="1">
<li><a class="el" href="js-dependencies.html#js-default-deps">Janus.useDefaultDependencies</a> which relies on native browser APIs, which in turn require somewhat more modern browsers</li>
<li><a class="el" href="js-dependencies.html#js-old-deps">Janus.useOldDependencies</a> which uses jQuery (<a href="http://jquery.com/">http://jquery.com/</a>) instead, and should provide equivalent behaviour to previous versions of <code>janus.js</code> </li>
</ol>
<p>By default <a class="el" href="js-dependencies.html#js-default-deps">Janus.useDefaultDependencies</a> will be used, but you can override this when initialising the Janus library and pass a custom dependencies object instead. For details, refer to: <a class="el" href="js-dependencies.html">Working with custom janus.js dependencies</a></p>
<p>In general, when using the Janus features, you would normally do the following:</p>
<ol type="1">
<li>include the Janus JavaScript library in your web page;</li>
<li>initialize the Janus JavaScript library and (optionally) passing its dependencies;</li>
<li>connect to the server and create a session;</li>
<li>create one or more handles to attach to a plugin (e.g., echo test and/or streaming);</li>
<li>interact with the plugin (sending/receiving messages, negotiating a PeerConnection);</li>
<li>eventually, close all the handles and shutdown the related PeerConnections;</li>
<li>destroy the session.</li>
</ol>
<p>The above steps will be presented in order, describing how you can use the low level API to accomplish them. Consider that in the future we might provide higher level wrappers to this API to address specific needs, e.g., a higher level API for each plugin: this would make it even easier to use the server features, as a high level API for the streaming plugin, for instance, may just ask you to provide the server address and the ID of the <code>&lt;video&gt;</code> element to display the stream in, and would take care of all the above mentioned steps on your behalf. Needless to say, you're very welcome to provide wrapper APIs yourself, if you feel a sudden urge to do so! :-)</p>
<h1><a class="anchor" id="janusjs"></a>
Using janus.js</h1>
<p>As a first step, you should include the Janus library in your project. Depending on your needs you can either use <code>janus.js</code> or one of the generated JavaScript module variants of it. For available module syntaxes and how to build the corresponding variants, see: <a class="el" href="js-modules.html">Using janus.js as JavaScript module</a></p>
<pre class="fragment">&lt;script type="text/javascript" src="janus.js" &gt;&lt;/script&gt;
</pre><p>The core of the JavaScript API is the <code>Janus</code> object. This object needs to be initialized the first time it is used in a page. This can be done using the static <code>init</code> method of the object, which accepts the following options:</p>
<ul>
<li><code>debug:</code> whether debug should be enabled on the JavaScript console, and what levels<ul>
<li><code>true</code> or <code>"all"</code>: all debuggers enabled (Janus.trace, Janus.debug, Janus.log, Janus.warn, Janus.error)</li>
<li>array (e.g., <code>["trace", "warn"]</code>): only enable selected debuggers (allowed tokens: trace, debug, log, warn, error)</li>
<li><code>false:</code> disable all debuggers</li>
</ul>
</li>
<li><code>callback:</code> a user provided function that is invoked when the initialization is complete</li>
<li><code>dependencies:</code> a user provided implementation of Janus library dependencies</li>
</ul>
<p>Here's an example:</p>
<pre class="fragment">Janus.init({
   debug: true,
   dependencies: Janus.useDefaultDependencies(), // or: Janus.useOldDependencies() to get the behaviour of previous Janus versions
   callback: function() {
           // Done!
   });</pre><dl class="section note"><dt>Note</dt><dd>When using one of the JavaScript module variants of <code>janus.js</code>, you will need to import the <code>Janus</code> symbol from the module first. See also: <a class="el" href="js-modules.html">Using janus.js as JavaScript module</a> For example, using the ECMAScript module variant, the above example should be altered to:</dd></dl>
<pre class="fragment">import * as Janus from './janus.es.js'

Janus.init({
   debug: true,
   dependencies: Janus.useDefaultDependencies(), // or: Janus.useOldDependencies() to get the behaviour of previous Janus versions
   callback: function() {
           // Done!
   });
});</pre><p>Once the library has been initialized, you can start creating sessions. Normally, each browser tab will need a single session with the server: in fact, each Janus session can contain several different plugin handles at the same time, meaning you can start several different WebRTC sessions with the same or different plugins for the same user using the same Janus session. That said, you're free to set up different Janus sessions in the same page, should you prefer so.</p>
<p>Creating a session is quite easy. You just need to use the <code>new</code> constructor to create a new <code>Janus</code> object that will handle your interaction with the server. Considering the dynamic and asynchronous nature of Janus sessions (events may occur at any time), there are several properties and callbacks you can configure when creating a session:</p>
<ul>
<li><code>server:</code> the address of the server as a specific address (e.g., <a href="http://yourserver:8088/janus">http://yourserver:8088/janus</a> to use the plain HTTP API or ws://yourserver:8188/ for WebSockets) or as an array of addresses to try sequentially to allow automatic for fallback/failover during setup;</li>
<li><code>iceServers:</code> a list of STUN/TURN servers to use (a default STUN server will be used if you skip this property);</li>
<li><code>ipv6:</code> whether IPv6 candidates should be gathered or not;</li>
<li><code>withCredentials:</code> whether the <code>withCredentials</code> property of XHR requests should be enabled or not (false by default, and only valid when using HTTP as a transport, ignored for WebSockets);</li>
<li><code>max_poll_events:</code> the number of events that should be returned when polling; the default is 1 (polling returns an object), passing a higher number will have the backend return an array of objects instead (again, only valid for HTTP usage as this is strictly related to long polling, ignored for WebSockets);</li>
<li><code>destroyOnUnload:</code> whether we should destroy automatically try and destroy this session via Janus API when <code>onbeforeunload</code> is called (true by default);</li>
<li><code>token</code> , <code>apisecret:</code> optional parameters only needed in case you're <a class="el" href="auth.html">Authenticating the Janus API</a> ;</li>
<li>a set of callbacks to be notified about events, namely:<ul>
<li><code>success:</code> the session was successfully created and is ready to be used;</li>
<li><code>error:</code> the session was NOT successfully created;</li>
<li><code>destroyed:</code> the session was destroyed and can't be used any more.</li>
</ul>
</li>
</ul>
<p>These properties and callbacks are passed to the method as properties of a single parameter object: that is, the <code>Janus</code> constructor takes a single parameter, which although acts as a container for all the available options. The <code>success</code> callback is where you typically start your application logic, e.g., attaching the peer to a plugin and start a media session.</p>
<p>Here's an example:</p>
<pre class="fragment">var janus = new Janus(
        {
                server: 'http://yourserver:8088/janus',
                success: function() {
                        // Done! attach to plugin XYZ
                },
                error: function(cause) {
                        // Error, can't go on...
                },
                destroyed: function() {
                        // I should get rid of this
                }
        });</pre><p>As anticipated, the server may be a specific address, e.g.:</p>
<pre class="fragment">var janus = new Janus(
        {
                server: 'http://yourserver:8088/janus',
                                // or
                server: 'ws://yourserver:8188/',
                [..]</pre><p>or an array of addresses. Such an array can be especially useful if you want the library to first check if the WebSockets server is reachable and, if not, fallback to plain HTTP, or just to provide a link multiple instances to try for failover. This is an example of how to pass a 'try websockets and fallback to HTTP' array:</p>
<pre class="fragment">var janus = new Janus(
        {
                server: ['ws://yourserver:8188/','http://yourserver:8088/janus'],
                [..]</pre><p>Once created, this object represents your session with the server. you can interact with a <code>Janus</code> object in several different ways. In particular, the following properties and methods are defined:</p>
<ul>
<li><code>getServer()</code>: returns the address of the server;</li>
<li><code>isConnected()</code>: returns <code>true</code> if the Janus instance is connected to the server, <code>false</code> otherwise;</li>
<li><code>getSessionId()</code>: returns the unique Janus session identifier;</li>
<li><code>attach(parameters)</code>: attaches the session to a plugin, creating a handle; more handles to the same or different plugins can be created at the same time;</li>
<li><code>destroy(parameters)</code>: destroys the session with the server, and closes all the handles (and related PeerConnections) the session may have with any plugin as well.</li>
</ul>
<p>The most important property is obviously the <code>attach()</code> method, as it's what will allow you to exploit the features of a plugin to manipulate the media sent and/or received by a PeerConnection in your web page. This method will create a plugin handle you can use for the purpose, for which you can configure properties and callbacks when calling the <code>attach()</code> method itself. As for the <code>Janus</code> constructor, the <code>attach()</code> method takes a single parameter that can contain any of the following properties and callbacks:</p>
<ul>
<li><code>plugin:</code> the unique package name of the plugin (e.g., <code>janus.plugin.echotest</code> );</li>
<li><code>opaqueId:</code> an optional opaque string meaningful to your application (e.g., to map all the handles of the same user);</li>
<li>a set of callbacks to be notified about events, namely:<ul>
<li><code>success:</code> the handle was successfully created and is ready to be used;</li>
<li><code>error:</code> the handle was NOT successfully created;</li>
<li><code>consentDialog:</code> this callback is triggered just before <code>getUserMedia</code> is called (parameter=<b>true</b>) and after it is completed (parameter=<b>false</b>); this means it can be used to modify the UI accordingly, e.g., to prompt the user about the need to accept the device access consent requests;</li>
<li><code>webrtcState:</code> this callback is triggered with a <b>true</b> value when the PeerConnection associated to a handle becomes active (so ICE, DTLS and everything else succeeded) from the Janus perspective, while <b>false</b> is triggered when the PeerConnection goes down instead; useful to figure out when WebRTC is actually up and running between you and Janus (e.g., to notify a user they're actually now active in a conference); notice that in case of <b>false</b> a reason string may be present as an optional parameter;</li>
<li><code>iceState:</code> this callback is triggered when the ICE state for the PeerConnection associated to the handle changes: the argument of the callback is the new state as a string (e.g., "connected" or "failed");</li>
<li><code>mediaState:</code> this callback is triggered when Janus starts or stops receiving your media: for instance, a <code>mediaState</code> with type=<b>audio</b> and on=<b>true</b> means Janus started receiving your audio stream (or started getting them again after a pause of more than a second); a <code>mediaState</code> with type=<b>video</b> and on=<b>false</b> means Janus hasn't received any video from you in the last second, after a start was detected before; useful to figure out when Janus actually started handling your media, or to detect problems on the media path (e.g., media never started, or stopped at some time);</li>
<li><code>slowLink:</code> this callback is triggered when Janus reports trouble either sending or receiving media on the specified PeerConnection, typically as a consequence of too many NACKs received from/sent to the user in the last second: for instance, a <code>slowLink</code> with uplink=<b>true</b> means you notified several missing packets from Janus, while uplink=<b>false</b> means Janus is not receiving all your packets; useful to figure out when there are problems on the media path (e.g., excessive loss), in order to possibly react accordingly (e.g., decrease the bitrate if most of our packets are getting lost);</li>
<li><code>onmessage:</code> a message/event has been received from the plugin;</li>
<li><code>onlocaltrack:</code> a local <code>MediaStreamTrack</code> is available and ready to be displayed;</li>
<li><code>onremotetrack:</code> a remote <code>MediaStreamTrack</code> is available and ready to be displayed;</li>
<li><code>ondataopen:</code> a Data Channel is available and ready to be used;</li>
<li><code>ondata:</code> data has been received through the Data Channel;</li>
<li><code>oncleanup:</code> the WebRTC PeerConnection with the plugin was closed;</li>
<li><code>detached:</code> the plugin handle has been detached by the plugin itself, and so should not be used anymore.</li>
</ul>
</li>
</ul>
<p>Here's an example:</p>
<pre class="fragment">// Attach to echo test plugin, using the previously created janus instance
janus.attach(
        {
                plugin: "janus.plugin.echotest",
                success: function(pluginHandle) {
                        // Plugin attached! 'pluginHandle' is our handle
                },
                error: function(cause) {
                        // Couldn't attach to the plugin
                },
                consentDialog: function(on) {
                        // e.g., Darken the screen if on=true (getUserMedia incoming), restore it otherwise
                },
                onmessage: function(msg, jsep) {
                        // We got a message/event (msg) from the plugin
                        // If jsep is not null, this involves a WebRTC negotiation
                },
                onlocaltrack: function(track, added) {
                        // A local track to display has just been added (getUserMedia worked!) or removed
                },
                onremotetrack: function(track, mid, added) {
                        // A remote track (working PeerConnection!) with a specific mid has just been added or removed
                },
                oncleanup: function() {
                        // PeerConnection with the plugin closed, clean the UI
                        // The plugin handle is still valid so we can create a new one
                },
                detached: function() {
                        // Connection with the plugin closed, get rid of its features
                        // The plugin handle is not valid anymore
                }
        });</pre><p>So the <code>attach()</code> method allows you to attach to a plugin, and specify the callbacks to invoke when anything relevant happens in this interaction. To actively interact with the plugin, you can use the <code>Handle</code> object that is returned by the <code>success</code> callback (pluginHandle in the example).</p>
<p>This <code>Handle</code> object has several methods you can use to interact with the plugin or check the state of the session handle:</p>
<ul>
<li><code>getId()</code>: returns the unique handle identifier;</li>
<li><code>getPlugin()</code>: returns the unique package name of the attached plugin;</li>
<li><code>send(parameters)</code>: sends a message (with or without a jsep to negotiate a PeerConnection) to the plugin;</li>
<li><code>createOffer(callbacks)</code>: asks the library to create a WebRTC compliant OFFER;</li>
<li><code>createAnswer(callbacks)</code>: asks the library to create a WebRTC compliant ANSWER;</li>
<li><code>handleRemoteJsep(callbacks)</code>: asks the library to handle an incoming WebRTC compliant session description;</li>
<li><code>dtmf(parameters)</code>: sends a DTMF tone on the PeerConnection;</li>
<li><code>data(parameters)</code>: sends data through the Data Channel, if available;</li>
<li><code>getBitrate(mid)</code>: gets a verbose description of the currently received video stream bitrate (optional mid to specify the stream, first video stream if missing);</li>
<li><code>hangup(sendRequest)</code>: tells the library to close the PeerConnection; if the optional <code>sendRequest</code> argument is set to <code>true</code>, then a <code>hangup</code> Janus API request is sent to Janus as well (disabled by default, Janus can usually figure this out via DTLS alerts and the like but it may be useful to enable it sometimes);</li>
<li><code>detach(parameters)</code>: detaches from the plugin and destroys the handle, tearing down the related PeerConnection if it exists.</li>
</ul>
<p>While the <code>Handle</code> API may look complex, it's actually quite straightforward once you get the concept. The only step that may require a little more effort to understand is the PeerConnection negotiation, but again, if you're familiar with the WebRTC API, the <code>Handle</code> actually makes it a lot easier.</p>
<p>The idea behind it's usage is the following:</p>
<ol type="1">
<li>you use <code>attach()</code> to create a <code>Handle</code> object;</li>
<li>in the <code>success</code> callback, your application logic can kick in: you may want to send a message to the plugin (<code>send({msg})</code>), negotiate a PeerConnection with the plugin right away ( <code>createOffer</code> followed by a <code>send({msg, jsep})</code>) or wait for something to happen to do anything;</li>
<li>the <code>onmessage</code> callback tells you when you've got messages from the plugin; if the <code>jsep</code> parameter is not null, just pass it to the library, which will take care of it for you; if it's an <b>OFFER</b> use <code>createAnswer</code> (followed by a <code>send({msg, jsep})</code> to close the loop with the plugin), otherwise use <code>handleRemoteJsep</code> ;</li>
<li>whether you took the initiative to set up a PeerConnection or the plugin did, the <code>onlocaltrack</code> and/or the <code>onremotetrack</code> callbacks will provide you with info on media tracks you can display or play in your page;</li>
<li>each plugin may allow you to manipulate what should flow through the PeerConnection channel: the <code>send</code> method and <code>onmessage</code> callback will allow you to handle this interaction (e.g., to tell the plugin to mute your stream, or to be notified about someone joining a virtual room), while the <code>ondata</code> callback is triggered whenever data is received on the Data Channel, if available (and the <code>ondataopen</code> callback will tell you when a Data Channel is actually available).</li>
</ol>
<p>The following paragraphs will delve a bit deeper in the negotiation mechanism provided by the <code>Handle</code> API, in particular describing the properties and callbacks that may be involved. To follow the approach outlined by the W3C WebRTC API, this negotiation mechanism is heavily based on asynchronous methods as well. Notice that the following paragraphs address the first negotiation step, that is the one to create a new PeerConnection from scratch: to know how to originate or handle a renegotiation instead (e.g., to add/remove/replace a media source, or force an ICE restart) check the <a class="el" href="JS.html#renegotiation">Updating an existing PeerConnection (renegotiations)</a> section instead.</p>
<ul>
<li><code>createOffer</code> takes a single parameter, that can contain any of the following properties and callbacks:<ul>
<li><code>media:</code> you can use this property to tell the library which media (audio/video/data) you're interested in, and whether you're going to send and/or receive any of them; by default audio and video are enabled in both directions, while the Data Channels are disabled; this option is an object that can take any of the following properties:<ul>
<li><code>audioSend:</code> <code>true/false</code> (do or do not send audio);</li>
<li><code>audioRecv:</code> <code>true/false</code> (do or do not receive audio);</li>
<li><code>audio:</code> <code>true/false</code> (do or do not send <b>and</b> receive audio, takes precedence on the above);</li>
<li><code>audio:</code> object with <code>deviceId</code> property (specify ID of audio device to capture, takes precedence on the above; devices list can be accessed with <code>Janus.listDevices(callback)</code> );</li>
<li><code>videoSend:</code> <code>true/false</code> (do or do not send video);</li>
<li><code>videoRecv:</code> <code>true/false</code> (do or do not receive video);</li>
<li><code>video:</code> <code>true/false</code> (do or do not send <b>and</b> receive video, takes precedence on the above);</li>
<li><code>video:</code> <code>"lowres"/"lowres-16:9"/"stdres"/"stdres-16:9"/"hires"/"hires-16:9"</code> (send a 320x240/320x180/640x480/640x360/1280x720 video, takes precedence on the above; default is <code>"stdres"</code> ) this property will affect the resulting getUserMedia that the library will issue; please notice that Firefox doesn't support the <code>"16:9"</code> variants, which will fallback to the ones; besides, <code>"hires"</code> and <code>"hires-16:9"</code> are currently synonymous, as there's no 4:3 high resolution constraint as of now;</li>
<li><code>video:</code> <code>"screen"</code> (use screensharing for video, disables audio, takes precedence on both audio and video);</li>
<li><code>video:</code> object with <code>deviceId</code> , <code>width</code> and/or <code>height</code> properties (specify ID of video device to capture and optionally resolution to use, takes precedence on the above; devices list can be accessed with <code>Janus.listDevices(callback)</code> );</li>
<li><code>data:</code> <code>true/false</code> (do or do not use Data Channels, default is false)</li>
<li><code>failIfNoAudio:</code> <code>true/false</code> (whether a getUserMedia should fail if audio send is asked, but no audio device is available, default is false)</li>
<li><code>failIfNoVideo:</code> <code>true/false</code> (whether a getUserMedia should fail if video send is asked, but no video device is available, default is false)</li>
<li><code>screenshareFrameRate:</code> in case you're sharing a screen/application, allows you to specify the framerate (default=3);</li>
</ul>
</li>
<li><code>trickle:</code> <code>true/false</code>, to tell the library whether you want Trickle ICE to be used (true, the default) or not (false);</li>
<li><code>stream:</code> optional, only to be passed in case you obtained a MediaStream object yourself with a <code>getUserMedia</code> request, and that you want the library to use instead of having it get one by itself (makes the <code>media</code> property useless, as it won't be read for accessing any device);</li>
<li>a set of callbacks to be notified about the result, namely:<ul>
<li><code>success:</code> the session description was created (attached as a parameter) and is ready to be sent to the plugin;</li>
<li><code>error:</code> the session description was NOT successfully created;</li>
<li><code>customizeSdp:</code> you can modify the sdp generated by the webrtc engine if you need;</li>
</ul>
</li>
</ul>
</li>
<li><code>createAnswer</code> takes the same options as createOffer, but requires an additional one as part of the single parameter argument:<ul>
<li><code>jsep:</code> the session description sent by the plugin (e.g., as received in an <code>onmessage</code> callback) as its OFFER.</li>
</ul>
</li>
</ul>
<p>Whether you use <code>createOffer</code> or <code>createAnswer</code> depending on the scenario, you should end up with a valid <code>jsep</code> object returned in the <code>success</code> callback. You can attach this <code>jsep</code> object to a message in a <code>send</code> request to pass it to the plugin, and have Janus negotiate a PeerConnection with your application.</p>
<p>Here's an example of how to use <code>createOffer</code>, taken from the Echo Test demo page:</p>
<pre class="fragment">// Attach to echo test plugin
janus.attach(
        {
                plugin: "janus.plugin.echotest",
                success: function(pluginHandle) {
                        // Negotiate WebRTC
                        echotest = pluginHandle;
                        var body = { "audio": true, "video": true };
                        echotest.send({"message": body});
                        echotest.createOffer(
                                {
                                        // No media property provided: by default,
                                                // it's sendrecv for audio and video
                                        success: function(jsep) {
                                                // Got our SDP! Send our OFFER to the plugin
                                                echotest.send({"message": body, "jsep": jsep});
                                        },
                                        error: function(error) {
                                                // An error occurred...
                                        },
                                        customizeSdp: function(jsep) {
                                                // if you want to modify the original sdp, do as the following
                                                // oldSdp = jsep.sdp;
                                                // jsep.sdp = yourNewSdp;
                                        }
                                });
                },
                [..]
                onmessage: function(msg, jsep) {
                        // Handle msg, if needed, and check jsep
                        if(jsep !== undefined &amp;&amp; jsep !== null) {
                                // We have the ANSWER from the plugin
                                echotest.handleRemoteJsep({jsep: jsep});
                        }
                },
                [..]
                onlocaltrack: function(track, added) {
                        // Invoked after createOffer
                        // This is info on a local track: when added, we can choose to render
                },
                onremotetrack: function(track, mid, added) {
                        // Invoked after handleRemoteJsep has got us a PeerConnection
                        // This is info on a remote track: when added, we can choose to render
                },
                [..]</pre><p>This, instead, is an example of how to use <code>createAnswer</code>, taken from the Streaming demo page:</p>
<pre class="fragment">// Attach to the Streaming plugin
janus.attach(
        {
                plugin: "janus.plugin.streaming",
                success: function(pluginHandle) {
                        // Handle created
                        streaming = pluginHandle;
                        [..]
                },
                [..]
                onmessage: function(msg, jsep) {
                        // Handle msg, if needed, and check jsep
                        if(jsep !== undefined &amp;&amp; jsep !== null) {
                                // We have an OFFER from the plugin
                                streaming.createAnswer(
                                        {
                                                // We attach the remote OFFER
                                                jsep: jsep,
                                                // We want recvonly audio/video
                                                media: { audioSend: false, videoSend: false },
                                                success: function(ourjsep) {
                                                        // Got our SDP! Send our ANSWER to the plugin
                                                        var body = { "request": "start" };
                                                        streaming.send({"message": body, "jsep": ourjsep});
                                                },
                                                error: function(error) {
                                                        // An error occurred...
                                                }
                                        });
                        }
                },
                [..]
                onlocaltrack: function(track, added) {
                        // This will NOT be invoked, we chose recvonly
                },
                onremotetrack: function(track, mid, added) {
                        // Invoked after send has got us a PeerConnection
                        // This is info on a remote track: when added, we can choose to render
                },
                [..]</pre><p>Of course, these are just a couple of examples where the scenarios assumed that one plugin would only receive (Echo Test) or generate (Streaming) offers. A more complex example (e.g., a Video Call plugin) would involve both, allowing you to either send offers to a plugin, or receive some from them. Handling this is just a matter of checking the <code>type</code> of the <code>jsep</code> object and reacting accordingly.</p>
<h1><a class="anchor" id="renegotiation"></a>
Updating an existing PeerConnection (renegotiations)</h1>
<p>While the JavaScript APIs described above will suffice for most of the common scenarios, there are cases when updates on a PeerConnection may be needed. This can happen whenever, for instance, you want to add a new media source (e.g., add video to an audio only call), replace an existing one (e.g., switch from capturing the camera to sharing your screen), or trigger an ICE restart because of a network change. All these actions require a renegotiation to occur, which means a new SDP offer/answer round to update the existing PeerConnection.</p>
<p>Since version <code>0.2.6</code>, renegotiations are indeed supported by Janus, and the <code>janus.js</code> library exposes ways to easily handle the process of updating a media session. More specifically, there are additional properties you can pass to <code>createOffer</code> and <code>createAnswer</code> for the purpose: most of the properties introduced in the previous section will still be usable, as it will be clearer in the next paragraphs.</p>
<p>The new properties you can pass to <code>media</code> in <code>createOffer</code> and <code>createAnswer</code> are the following:</p>
<ul>
<li><code>addAudio:</code> if set, start capturing audio if you weren't (will fail if you're sending audio already);</li>
<li><code>addVideo:</code> if set, start capturing video if you weren't (will fail if you're sending video already);</li>
<li><code>addData:</code> if set, negotiate a datachannel if it didn't exist (is actually just a synonym for <code>data:true</code> );</li>
<li><code>removeAudio:</code> if set, stop capturing audio and remove the local audio track;</li>
<li><code>removeVideo:</code> if set, stop capturing video and remove the local video track;</li>
<li><code>replaceAudio:</code> if set, stop capturing the current audio (remove the local audio track), and capture a new audio source;</li>
<li><code>replaceVideo:</code> if set, stop capturing the current video (remove the local video track), and capture a new video source.</li>
</ul>
<p>Notice that these properties are only processed when you're trying a renegotiation, and will be ignored when creating a new PeerConnection.</p>
<p>These properties don't replace the existing <code>media</code> properties, but go along with them. For instance, when adding a new video stream, or replacing an existing one, you can still use the video related properties as before, e.g., to pass a specific device ID or asking for a screenshare instead of a camera. Besides, notice that you'll currently have to pass info on the streams you want to keep as well, or they might be removed: this means that, if for instance you want to replace the video source, but want to keep the audio as it is, passing <code>audio:false</code> to the new createOffer will potentially disable audio.</p>
<p>It's important to point out that, as for negotiations that result in the creation of a new PeerConnection in the first place, how to perform a renegotiation in practice will typically vary depending on the plugin that you're trying to do it for. Some plugins may allow you to offer a renegotiation, others may require you to send a different request instead in order to trigger a renegotiation from the plugin. As it will be clearer later, this is especially true for ICE restarts. As such, apart from the generic and core-related definitions introduced in this section, please refer to the documentation for each individual plugin for more information about how to perform renegotiations in specific use cases.</p>
<p>Here's a simple example of how you can use <code>removeVideo</code> to remove the local video capture in a session, e.g., in the EchoTest demo:</p>
<pre class="fragment">// Remove local video
echotest.createOffer(
    {
        media: { removeVideo: true },
        success: function(jsep) {
            Janus.debug(jsep);
            echotest.send({message: {audio: true, video: true}, "jsep": jsep});
        },
        error: function(error) {
            bootbox.alert("WebRTC error... " + JSON.stringify(error));
        }
    });</pre><p>This other example shows how you can add a new video stream to an-audio only PeerConnection instead:</p>
<pre class="fragment">// Add local video
echotest.createOffer(
    {
        media: { addVideo: true },
        success: function(jsep) {
            Janus.debug(jsep);
            echotest.send({message: {audio: true, video: true}, "jsep": jsep});
        },
        error: function(error) {
            bootbox.alert("WebRTC error... " + JSON.stringify(error));
        }
    });</pre><p>Finally, this example shows how you can replace the video track, by also showing how you can combine this with one of the properties we already met in the previous section:</p>
<pre class="fragment">// Replace local video
echotest.createOffer(
    {
        media: {
            video: {
                deviceId: "44f4740bee234ce6ddcfea8e59e8ed7505054f75edf27e3a12294686b37ff6a7"
            },
            replaceVideo: true
        },
        success: function(jsep) {
            Janus.debug(jsep);
            echotest.send({message: {audio: true, video: true}, "jsep": jsep});
        },
        error: function(error) {
            bootbox.alert("WebRTC error... " + JSON.stringify(error));
        }
    });</pre><p>Notice that renegotiations involving media changes (both local and remote) will likely result in new calls to the <code>onlocaltrack</code> and <code>onremotetrack</code> application callbacks: as such, be prepared to see those callbacks called for the same PeerConnection more than once during the course of a media session.</p>
<h1><a class="anchor" id="restarts"></a>
ICE restarts</h1>
<p>While ICE restarts can be achieved with a renegotiation, they're complex enough to deserve a specific subsection. In fact, ICE restarts don't address changes in the media, but in the underlying transport itself. They're used, for instance, when there's a network change (e.g., the IP address changed, or the user switched from WiFi to 4G). In order for this to work, new candidates must be exchanged, and connectivity checks must be restarted in order to find the new optimal path.</p>
<p>With <code>janus.js</code>, you can only force an ICE restart when sending a new offer. In order to do so, all you need to do is add <code>iceRestart:true</code> to your <code>createOffer</code> call, and an ICE restart will be requested. The following example shows how this can be done with the EchoTest:</p>
<pre class="fragment">echotest.createOffer({
    iceRestart: true,
    media: { data: true },
    success: function(jsep) {
        echotest.send({message: {audio: true, video: true}, jsep: jsep});
        }
});</pre><p>In this particular example, we're not asking for any change on the media streams, but just an ICE restart. If successful, as soon as the answer is received, the client and Janus will restart the ICE process and find a new path for the media packets.</p>
<p>Notice that, with Janus and its plugins, you won't always be able to force an ICE restart by sending a new SDP offer yourself: some plugins, like the Streaming plugin for instance, will want to always send an offer themselves, which means they'll be the ones actually forcing the ICE restart from a negotiation perspective. In order to still allow users to actually originate the process, all the stock Janus plugins that assume they'll be sending offers for some or all of their media streams also expose APIs to force an ICE restart from the server side. You can learn more about this on a plugin level basis <a href="https://github.com/meetecho/janus-gateway/pull/753" target="_blank">here</a> and <a href="https://github.com/meetecho/janus-gateway/pull/1099" target="_blank">here</a>. Besides, make sure you read the documentation for each of the plugins you're interested in using ICE restarts for, as the details for how to perform it properly are typically provided there.</p>
<hr/>
<p>This is it! For more information about the API, have a look at the demo pages that are available in the <b>html</b> folder in this package. </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.18-->
<!-- start footer part -->
<div class="footer container">
<hr class="footer"/>
Last updated on Fri Apr 9 2021 &mdash; Janus WebRTC Server &copy; <a target="_blank" href="http://www.meetecho.com/">Meetecho</a> 2014-2021
</div>
</body>
</html>
